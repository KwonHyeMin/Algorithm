/*
STL 간단 정리
<배열>
- 스택영역에 자료 저장하고, 컴파일 시 공간 확보
- 장점 : index로 접근 가능/자료의 접근과 저장이 빠름/자료 순차적 저장 가능
- 단점
1. 한번 확보한 배열크기 조절 쉽지 않음-> 메모리 낭비.
2. 중간 값 삽입/삭제가 어려움(shift힘듦)

<vector> : 동적배열
- 배열의 '단점1'을 보완
- 그러나 '단점2'는 극복x
(앞/뒤 삽입/삭제는 가능하지만 중간은 불가)
- 검색 속도 느림(data가 순차적으로 저장되니까..)
-> 물론 index를 안다면 배열처럼 쉽게접근 가능

<list> : vector의 단점인 중간값 삽입/삭제 가능해짐
- 포인터를 이용하여 다음 값을 찾는방식
-> 중간에서도 삽입/삭제 용이
- 단점 
1. vector처럼 data의 index로 접근 불가
2. 순차 접근이라 검색이 느림

<map> : key, value가 한 쌍이다
- 트리구조
- key를 기준으로 자동 정렬됨
- 검색 속도가 빠르다!(list,vector보다)
- 단점 : 삽입/삭제가 빈번하면 안된다 (매번 정렬하므로!)

<set> : map인데 key만 저장하는 map
- 마찬가지로 트리구조
- key를 신속하게 검색하고, key를 정렬할 때 사용


<총정리>
1. 간단하게 쓰고 싶다 -> 배열
2. 동적으로 쓰고 싶다 -> vector / list
- index로 검색하고 싶다-> vector
- 중간에 삽입/삭제하고 싶다 -> list
3. 검색 많이 할 것 같다(정렬도 됨) -> map (대신 삽입/삭제 자주하면 안됨)
4. 검색 많이 할거고 정렬도 할건데 key만 필요 -> set
---------STL아님----------
5. 검색 많이 할 거고 data도 많음, 정렬은 안함 -> hasy_map
6. 위의 경우인데 key만 필요 -> hash_set


*/


/*

<배열과 vector/list>
- 만약 간단하게 쓰고 싶을 때 : 배열
- 동적으로 쓰고 싶다면 : vector/list


<vector 와 list의 차이점>
- vector : 메모리 할당을 연속적으로(배열과 비슷)
-> 미리 일정크기 할당한 후 그 이상의 값들이 추가되면 새로운 더 큰 메모리를 할당한다
- list : 메모리 할당을 자유롭게 따로따로(linked list와 비슷)
-> 값을 넣을 때마다 메모리를 할당

그래서!
- pushback/popback : vector가 더 빠름(매번 메모리 할당 안하니까)
- 중간에 추가하는 insert,delete : list가 더 빠름(vector는 배열을 계속 재구성해야하니까)

그렇다면 메모리 해제는!
- vector : 값 삭제해도 메모리 해제 안함(심지어 clear해도 메모리는 그대로!)
- list : 변수가 해제될 때마다 메모리에서 해제

정리! 
- 맨 뒤에서 추가, 삭제가 일어나는 경우 vector가 빠르며 메모리 손실도 적다
즉, 순서가 상관없거나 순차적으로 추가/삭제 : vector가 유리
- 순서가 중요해서 중간에 추가,삭제가 되는 경우 메모리는 물론 많이 잡아먹지만 속도가 엄청 빠르기에 : list가 유리
- 일반적으로는 vector가 list보다 메모리 더 적게 사용! 왜냐면 vector는 연속적인 주소에 할당되므로 list처럼 next등의 추가적인 다른 변수 가질 필요 없거든!

*/
